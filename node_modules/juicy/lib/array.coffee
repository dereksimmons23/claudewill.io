Array::merge = (arr) ->
	return no if not arr instanceof Array
	

Array::eql = (arr) ->
	return no if not arr instanceof Array
	
	eqlArray @, arr

eqlArray = (src, dest) ->
	return no if not src instanceof Array or not dest instanceof Array  # no need to continue

	length = src.length # caching length of this array
	return no if length != dest.length # lengths don't match, arrays are not the same

	i = 0

	loop
		break if i is length

		if src[i] instanceof Object
			return no if not src[i].eql dest[i] # recursive eql()
		else
			return no if src[i] != dest[i]

		i++

	yes

Array::collect = (block) ->
	result = []
	
	result.push block(item) for item in @
	
	result

Array::combination = (size) ->
	return [] if size <= 0 or @length is 0
	
	result = []
	clone = [] # cloning this array to avoid its modification
	clone.push item for item in @
	currentSize = 0
	chunk = []
	
	for item in @		
		if currentSize < size
			chunk.push item
		else
			result.push chunk
			chunk = []
			chunk.push item
			currentSize = 0
		
		currentSize++
	
	result.push chunk if chunk.length > 0 # pushing left elements
	
	result

Array::compact = ->
	result = []
	
	for item in @
		result.push item if item != undefined and item != null
	
	result

Array::merge = (arr) ->
	result = []
	
	result.push item for item in @
	for item in arr
		@push item
		result.push item
	
	result

Array::count = (block) ->
	return @length if typeof block != 'function'
	
	result = 0
	
	for item in @
		result++ if block(item)
	
	result

Array::remove = (value) ->
	return if not value
	
	removed = undefined # returning removed value
	
	loop
		index = @indexOf value
		return removed if index < 0
		
		@removeAt index
		removed = value
	
Array::removeAt = (index) ->
	return if index < 0
	
	@splice index, 1

Array::removeIf = (block) ->
	return if typeof block != 'function'
	
	result = []
	
	for item in @
		result.push item if not block(item)
	
	result

Array::drop = (num) ->
	@splice 0, num

Array::dropWhile = (block) ->
	return if typeof block != 'function'
	
	result = []
	
	for item in @
		result.push item if not block(item)
	
	result

Array::eachIndex = (block) ->
	return if typeof block != 'function'
	
	i = 0
	length = @length # caching own length
	
	loop
		break if i is length
		
		block(i)
		i++

Array::flatten = ->
	result = []
	
	flatten = (arr, target) -> # recursive flatten
		for item in arr
			if item instanceof Array
				flatten item, target
			else
				target.push item
	
	flatten @, result
	
	result

Array::take = (num) ->
	return if num < 1 # we can't take 0 elements
	
	result = []
	i = 0
	length = @length # caching own length
	
	loop
		break if i is @length or i is num # hitting the limit
		
		result.push @[i]
		
		i++
	
	result

Array::takeWhile = (block) ->
	return if typeof block != 'function'
	
	result = []
	
	for item in @
		result.push item if block(item)
	
	result

Array::transpose = ->
	rows = []
	columns = []
	
	for item in @
		rows.push item[0]
		columns.push item[1]
	
	[rows, columns]

Array::__defineGetter__ 'transposed', ->
	@transpose()

Array::__defineGetter__ 'reversed', ->
	@reverse()

Array::__defineGetter__ 'compacted', ->
	@compact()

Array::__defineGetter__ 'flattened', ->
	@flatten()

Array::__defineGetter__ 'first', ->
	@[0]

Array::__defineSetter__ 'first', (value) ->
	@[0] = value

Array::__defineGetter__ 'last', ->
	@[@length - 1]

Array::__defineSetter__ 'last', (value) ->
	@[@length - 1] = value

Array::__defineGetter__ 'size', ->
	@length