if require?
	expect = require '../node_modules/expect.js'
	require '../'

describe 'Juicy', ->
	describe 'Object', ->
		it 'merge', ->
			obj=
				a: 1
			
			obj = Object.merge obj,
				b: 2
			
			expect(obj.a).to.be(1) and expect(obj.b).to.be(2)
		
		it 'eql', ->
			first=
				a: 1
				b: [2]
			
			second=
				a: 1
				b: [2]
			
			third=
				a: 1
				b: 2
				c: 3
			
			expect(Object.eql(first, second)).to.be(true) and expect(Object.eql(second, third)).to.be(false)
		
	describe 'Array', ->
		it 'collect', ->
			items = ['a', 'b'].collect (item) ->
				"#{ item }!"
			
			expect(items[0]).to.be('a!') and expect(items[1]).to.be('b!')
		
		it 'combination', ->
			items = ['a', 'b', 'c'].combination(0)
			expect(items.length).to.be(0)
			
			items = ['a', 'b', 'c'].combination(1)
			expect(items[0][0]).to.be('a') and expect(items[1][0]).to.be('b') and expect(items[2][0]).to.be('c')
			
			items = ['a', 'b', 'c'].combination(2)
			expect(items[0][0]).to.be('a') and expect(items[0][1]).to.be('b') and expect(items[1][0]).to.be('c')
			
			items = ['a', 'b', 'c'].combination(3)
			expect(items[0][0]).to.be('a') and expect(items[0][1]).to.be('b') and expect(items[0][2]).to.be('c') and
			expect(items[1]).to.be(undefined)
		
		it 'compact', ->
			items = ['a', false, 'b', null].compacted
			expect(items[0]).to.be('a') and expect(items[1]).to.be(false) and expect(items[2]).to.be('b')
		
		it 'merge', ->
			items = ['a'].merge ['b']
			expect(items[0]).to.be('a') and expect(items[1]).to.be('b')
		
		it 'count', ->
			count = ['a', 'b', 'c', 'd'].count (item) ->
				item > 'a'
			
			expect(count).to.be(3)
		
		it 'remove', ->
			items = ['a', 'b', 'c', 'a']
			items.remove('a')
			expect(items[0]).to.be('b') and expect(items[1]).to.be('c')
		
		it 'removeAt', ->
			items = ['a', 'b', 'c']
			items.removeAt(1)
			expect(items[0]).to.be('a') and expect(items[1]).to.be('c')
		
		it 'removeIf', ->
			items = ['a', 'b', 'c'].removeIf (item) ->
				item > 'a'
			
			expect(items[0]).to.be('a') and expect(items.length).to.be(1)
		
		it 'drop', ->
			items = ['a', 'b', 'c']
			items.drop(2)
			expect(items[0]).to.be('c') and expect(items.length).to.be(1)
		
		it 'dropWhile', ->
			items = ['a', 'b', 'c', 'd']
			items = items.dropWhile (item) ->
				item < 'd'
			
			expect(items[0]).to.be('d') and expect(items.length).to.be(1)
		
		it 'eachIndex', ->
			items = ['a', 'b', 'c']
			items.eachIndex (index) ->
				expect(!!items[index])
		
		it 'eql', ->
			first = ['a', ['b']]
			second = ['a', ['b']]
			third = ['a', ['b'], 'c']
			
			expect(first.eql(second)).to.be(true) and expect(first.eql(third)).to.be(false)
		
		it 'flatten', ->
			items = ['a', ['b'], [['c']]].flattened
			
			expect(items[0]).to.be('a') and expect(items[1]).to.be('b') and expect(items[2]).to.be('c')
		
		it 'take', ->
			items = ['a', 'b', 'c'].take(2)
			
			expect(items[0]).to.be('a') and expect(items[1]).to.be('b') and expect(items.length).to.be(2)
		
		it 'takeWhile', ->
			items = ['a', 'b', 'c'].takeWhile (item) ->
				item < 'c'
			
			expect(items[0]).to.be('a') and expect(items[1]).to.be('b') and expect(items.length).to.be(2)
		
		it 'transpose', ->
			[rows, columns] = [['a', 'c'], ['b', 'd']].transposed
			
			expect(rows[0]).to.be('a') and expect(columns[0]).to.be('c') and
			expect(rows[1]).to.be('b') and expect(columns[1]).to.be('d')
		
		it 'get first', ->
			expect(['a', 'b'].first).to.be('a')
		
		it 'set first', ->
			items = ['a', 'b']
			items.first = 'c'
			expect(items.first).to.be('c')
		
		it 'get last', ->
			expect(['a', 'b'].last).to.be('b')
		
		it 'set last', ->
			items = ['a', 'b']
			items.last = 'c'
			expect(items.last).to.be('c')
	
	describe 'String', ->
		it 'downcase', ->
			expect('GO'.downcase).to.be('go')
		
		it 'upcase', ->
			expect('go'.upcase).to.be('GO')