// Generated by CoffeeScript 1.3.3
var Lychee, async, fs, url;

url = require('url');

async = require('async');

fs = require('fs');

require('juicy');

Function.prototype.clone = function() {
  var clone, property;
  clone = function() {};
  for (property in this) {
    if (this.hasOwnProperty(property)) {
      clone[property] = this[property];
    }
  }
  clone.prototype = this.prototype;
  return clone;
};

Lychee = (function() {

  function Lychee() {}

  Lychee.drivers = {};

  Lychee.defaultDriver = '';

  Lychee.registerDriver = function(name, driver) {
    if (driver.Extensions) {
      Lychee.Model.include(driver.Extensions);
    }
    return this.drivers[name] = driver;
  };

  Lychee.connect = function(hosts, done) {
    var driver, host, params, _i, _len,
      _this = this;
    params = {};
    for (driver in this.drivers) {
      params[driver] = [];
    }
    for (_i = 0, _len = hosts.length; _i < _len; _i++) {
      host = hosts[_i];
      driver = url.parse(host).protocol.slice(0, -1);
      params[driver].push(host);
    }
    return async.forEach(Object.keys(params), function(driver, nextDriver) {
      return _this.drivers[driver].connect(params[driver], nextDriver);
    }, function() {
      if (done) {
        return done();
      }
    });
  };

  Lychee.disconnect = function(done) {
    var _this = this;
    return async.forEach(Object.keys(this.drivers), function(driver, nextDriver) {
      _this.drivers[driver].disconnect(nextDriver);
      return _this.drivers[driver].disconnect(nextDriver);
    }, function() {
      if (done) {
        return done();
      }
    });
  };

  Lychee.setDefaultDriver = function(name) {
    return this.defaultDriver = name;
  };

  Lychee.setup = function(model) {
    var field, key, keyExists, keys, _base, _base1, _i, _len, _ref;
    model.prototype.collectionName = model.collectionName || (model.collectionName = model.name.downcase.pluralized);
    keys = [];
    model.prototype.keys = model.prototype.keys.removeIf(function(item) {
      if (keys.indexOf(item.key) === -1) {
        keys.push(item.key);
        return false;
      } else {
        return true;
      }
    });
    (_base = model.prototype).scopes || (_base.scopes = []);
    if (model.prototype.scopes.length > 0) {
      model.prototype.scopes.forEach(function(scope) {
        return model[scope.name] = function(callback) {
          return this.find(scope.query, callback);
        };
      });
    }
    (_base1 = model.prototype).validators || (_base1.validators = {});
    for (key in model.prototype.validators) {
      keyExists = false;
      _ref = model.prototype.keys;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        field = _ref[_i];
        if (key === field.key) {
          keyExists = true;
        }
      }
      if (!keyExists) {
        delete model.prototype.validators[key];
      }
    }
    model.prototype.keys.forEach(function(field) {
      if (field.primary) {
        model.prototype.primaryKey = field.key;
      }
      model.prototype.__defineGetter__(field.key, function() {
        return this.get(field.key);
      });
      return model.prototype.__defineSetter__(field.key, function(value) {
        return this.set(field.key, value);
      });
    });
    ['driver', 'collection', 'scopes', 'scope', 'key', 'timestamps', 'validate', 'validates'].forEach(function(property) {
      return delete model[property];
    });
    model.prototype.driver = model.driver = new this.drivers[model.driverName || 'mongodb'](model);
    model.model = model.prototype.model = model;
    return model;
  };

  return Lychee;

})();

Lychee.Validators = (function() {

  function Validators() {}

  Validators.validators = [];

  Validators.register = function(validator) {
    return this.validators.push(validator);
  };

  return Validators;

})();

Lychee.Validators.register(require('./validators/string_length'));

Lychee.Validators.register(require('./validators/number_value'));

Lychee.Validators.register(require('./validators/presence'));

Lychee.Validators.register(require('./validators/acceptance'));

Lychee.Validators.register(require('./validators/confirmation'));

Lychee.Validators.register(require('./validators/with'));

Lychee.Validators.register(require('./validators/numericality'));

Lychee.Validators.register(require('./validators/condition'));

Lychee.Events = (function() {

  function Events() {}

  Events.listeners = {};

  Events.on = function(model, event, listener) {
    if (!this.listeners[model]) {
      this.listeners[model] = {};
    }
    if (!this.listeners[model][event]) {
      this.listeners[model][event] = [];
    }
    return this.listeners[model][event].push(listener);
  };

  Events.unbind = function(model, event) {
    return this.listeners[model][event] = [];
  };

  Events.emit = function(model, event, context) {
    var listener, _i, _len, _ref, _results;
    if (context == null) {
      context = this;
    }
    if (!(this.listeners[model] && this.listeners[model][event])) {
      return;
    }
    _ref = this.listeners[model][event];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listener = _ref[_i];
      _results.push(listener.call(context));
    }
    return _results;
  };

  return Events;

})();

Lychee.Model = (function() {

  function Model(fields) {
    this.fields = {};
    this.old = {};
    this.errors = [];
    this.isValid = void 0;
    this.updateAttributes(fields);
    this;

  }

  Model.prototype.get = function(key) {
    return this.fields[key];
  };

  Model.prototype.set = function(key, value) {
    if (this.fields[key] && (!this.old[key] || this.old[key] !== value)) {
      this.old[key] = this.fields[key];
    }
    return this.fields[key] = value;
  };

  Model.prototype.setDefaults = function() {
    var field, _i, _len, _ref, _results;
    _ref = this.keys;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      field = _ref[_i];
      if ((field instanceof Object) && field["default"] && !this.fields[field.key]) {
        _results.push(this.fields[field.key] = 'function' === typeof field["default"] ? field["default"]() : field["default"]);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Model.prototype.updateAttributes = function(fields) {
    var key, _results;
    if (fields == null) {
      fields = {};
    }
    _results = [];
    for (key in fields) {
      if (fields.hasOwnProperty(key)) {
        _results.push(this.set(key, fields[key]));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Model.prototype.update_attributes = function() {
    return this.updateAttributes.apply(this, arguments);
  };

  Model.driver = function(driverName) {
    this.driverName = driverName != null ? driverName : 'mongodb';
  };

  Model.collection = function(collectionName) {
    this.collectionName = collectionName;
  };

  Model.scope = function(name, query) {
    if (query == null) {
      query = {};
    }
    if (!this.prototype.scopes) {
      this.prototype.scopes = [];
    }
    return this.prototype.scopes.push({
      name: name,
      query: query
    });
  };

  Model.key = function(key, params) {
    if (params == null) {
      params = {};
    }
    if (!this.prototype.keys) {
      this.prototype.keys = [];
    }
    return this.prototype.keys.push(Object.merge({
      key: key
    }, params));
  };

  Model.prototype.key = function(key, params) {
    if (params == null) {
      params = {};
    }
    return this.keys.push(Object.merge({
      key: key
    }, params));
  };

  Model.timestamps = function(keys) {
    if (keys == null) {
      keys = {};
    }
    keys.create || (keys.create = 'created_at');
    keys.update || (keys.update = 'updated_at');
    this.prototype.timestamps = keys;
    this.key(keys.create, {
      "default": Date.now
    });
    return this.key(keys.update, {
      "default": Date.now
    });
  };

  Model.validates = function() {
    var detected, item, key, keys, params, validator, validators, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
    if (!this.prototype.validators) {
      this.prototype.validators = {
        all: []
      };
    }
    keys = [];
    params = {};
    if (arguments[0] instanceof Object && !arguments[1]) {
      keys.push('all');
      params = {
        "with": arguments[0]
      };
    } else {
      for (item in arguments) {
        if ('string' === typeof arguments[item]) {
          keys.push(arguments[item]);
        } else if ('object' === typeof arguments[item]) {
          params = arguments[item];
        }
      }
    }
    validators = [];
    _ref = Lychee.Validators.validators;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      validator = _ref[_i];
      detected = false;
      _ref1 = validator.detectBy;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        key = _ref1[_j];
        if (params[key]) {
          detected = true;
          break;
        }
      }
      if (detected) {
        validators.push(validator);
      }
    }
    for (_k = 0, _len2 = keys.length; _k < _len2; _k++) {
      key = keys[_k];
      if (!this.prototype.validators[key]) {
        this.prototype.validators[key] = [];
      }
      for (_l = 0, _len3 = validators.length; _l < _len3; _l++) {
        validator = validators[_l];
        this.prototype.validators[key].push(new validator(Object.merge({
          key: key
        }, params)));
      }
    }
    return void 0;
  };

  Model.validate = function() {
    return this.validates.apply(this, arguments);
  };

  Model.prototype.validate = function(callback) {
    var _this = this;
    this.errors = {
      all: []
    };
    this.isValid = true;
    return async.forEach(this.keys, function(field, nextKey) {
      if (!_this.validators[field.key]) {
        return nextKey();
      }
      return async.forEach(_this.validators[field.key], function(validator, nextValidator) {
        return validator.validate(_this.fields[field.key], function(valid, message) {
          if (!valid) {
            if (!_this.errors[field.key]) {
              _this.errors[field.key] = [];
            }
            _this.errors[field.key].push(message ? message : 'is not valid');
            _this.isValid = false;
          }
          return nextValidator();
        }, _this);
      }, function() {
        return nextKey();
      });
    }, function() {
      return callback(_this.isValid);
    });
  };

  Model.find = function(options, done) {
    var _this = this;
    if (options instanceof Function) {
      done = options;
      options = {};
    }
    return this.driver.find(options, function(err, items) {
      var item, model, models, _i, _len;
      models = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        model = new _this.model(item);
        models.push(model);
      }
      if (done) {
        return done(err, models);
      }
    });
  };

  Model.all = function() {
    return this.find.apply(this, arguments);
  };

  Model.prototype.save = function(params, done) {
    var next,
      _this = this;
    this.setDefaults();
    if ('function' === typeof params) {
      done = params;
      params = {
        validate: true
      };
    }
    next = function() {
      var handler;
      handler = function() {
        _this.callHook('aroundSave');
        _this.callHook('afterSave');
        Lychee.Events.emit(_this.collectionName, 'save', _this);
        if (done) {
          done();
        }
        _this.callHook('beforeSave');
        return _this.callHook('aroundSave');
      };
      if (_this.fields[_this.primaryKey]) {
        return _this.update(handler);
      } else {
        return _this.create(handler);
      }
    };
    if (params.validate || !(params.validate != null)) {
      return this.validate(function(valid) {
        if (!valid) {
          return done(true);
        }
        return next();
      });
    } else {
      return next();
    }
  };

  Model.prototype.create = function(done) {
    var _this = this;
    this.callHook('beforeCreate');
    this.callHook('aroundCreate');
    return this.driver.create(this.fields, function(err, fields) {
      var key, _i, _len, _ref;
      _ref = _this.keys;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        _this.set(key.key, fields[key.key]);
      }
      _this.callHook('aroundCreate');
      _this.callHook('afterCreate');
      Lychee.Events.emit(_this.collectionName, 'create', _this);
      if (done) {
        return done();
      }
    });
  };

  Model.prototype.update = function(done) {
    var _this = this;
    this.callHook('beforeUpdate');
    this.callHook('aroundUpdate');
    if (this.timestamps && this.timestamps.update) {
      delete this.fields[this.timestamps.update];
      this.setDefaults();
    }
    return this.driver.update(this.fields, function(err, fields) {
      _this.callHook('aroundUpdate');
      _this.callHook('aroundUpdate');
      Lychee.Events.emit(_this.collectionName, 'update', _this);
      if (done) {
        return done();
      }
    });
  };

  Model.prototype.remove = function(done) {
    var _this = this;
    this.callHook('beforeRemove');
    this.callHook('aroundRemove');
    return this.driver.remove(this.fields, function(err) {
      _this.callHook('aroundRemove');
      _this.callHook('afterRemove');
      Lychee.Events.emit(_this.collectionName, 'remove', _this);
      Object.freeze(_this.fields);
      if (done) {
        return done();
      }
    });
  };

  Model.remove = function(done) {
    var _this = this;
    return this.driver.removeAll(function(err) {
      Lychee.Events.emit(_this.collectionName, 'removeAll', _this);
      if (done) {
        return done();
      }
    });
  };

  Model.prototype.callHook = function(name) {
    var hook;
    hook = this[name] || this[name.underscored];
    if (hook) {
      return hook.call(this);
    }
  };

  Model.on = function(event, listener) {
    return Lychee.Events.on(this.collectionName, event, listener);
  };

  Model.bind = function() {
    return this.on.apply(this, arguments);
  };

  Model.unbind = function(event) {
    return Lychee.Events.unbind(this.collectionName, event);
  };

  return Model;

})();

Lychee.registerDriver('mongodb', require('./drivers/mongodb'));

Lychee.registerDriver('rest', require('./drivers/rest'));

module.exports = Lychee;
